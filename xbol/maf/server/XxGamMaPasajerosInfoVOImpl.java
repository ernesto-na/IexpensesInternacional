package xxgam.oracle.apps.xbol.maf.server;

import oracle.apps.fnd.framework.OAException;
import oracle.apps.fnd.framework.server.OAViewObjectImpl;

import oracle.jbo.Row;
import oracle.jbo.RowIterator;
import oracle.jbo.RowSetIterator;
import oracle.jbo.ViewCriteria;
import oracle.jbo.ViewCriteriaRow;
import oracle.jbo.domain.Number;


// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class XxGamMaPasajerosInfoVOImpl extends OAViewObjectImpl
{
  /**This is the default constructor (do not remove)
   */
  public XxGamMaPasajerosInfoVOImpl()
  {
  }

  void searchPasajerosInfo(Number ticketId,Number idGeneral)
  {
    //Verifica nulidad
    if (ticketId == null)
        return;
    try {
        //Declara los recursos    
        ViewCriteria vcTicket = null;
        ViewCriteriaRow rowVCTicket = null;

        //Crea el criterio de busqueda
        vcTicket = createViewCriteria();
        rowVCTicket = vcTicket.createViewCriteriaRow();
        rowVCTicket.setAttribute("TicketPId", ticketId);

        //Aplica el criterio
        vcTicket.addElement(rowVCTicket);
        applyViewCriteria(vcTicket);
        executeQuery();

        //Inicializa el current row
         System.out.println("getEstimatedRowCount() PasajerosInfo "+getEstimatedRowCount());
        if (getEstimatedRowCount() > 0) {
            setCurrentRow(first());
        }
        clearViewCriterias();
    } catch (Exception exception) {
         clearViewCriterias();
    }
    return;
          
  }

  /***
   * Metodo para borrar registros
   */

  void deleteRowPasajerosInfo(Number nInfoPasajeroId)
  {
    
    Row[] deleteRows = null;
    deleteRows = getFilteredRows("Id", nInfoPasajeroId);
    
    if (deleteRows != null) {
      if (deleteRows.length > 0) {
        deleteRows[0].remove();
        deleteRows = null;
        getFilteredRows("Id", nInfoPasajeroId);
        if (deleteRows != null) {
          if (deleteRows.length > 0) {
          }
        } else{
          throw new OAException("Registro borrado satisfactoriamente", OAException.INFORMATION);
        }
      }else{
        throw new OAException("Al preguntar si la longitud del registo es mayor que cero",OAException.WARNING );
      }
    }else{
      throw new OAException("Al preguntar si el registro es diferente de nulo",OAException.WARNING );
    }
        
  }

  /**
   * Crea un registro hijo del requerimiento principal.
   *
   * @param rowBase Row a copiar.
   * @return registro creado
   */
   
  public XxGamMaPasajerosInfoVORowImpl getPasajerosInfo(XxGamMaPasajerosInfoVORowImpl rowBase, 
                                                 RowIterator iterNuevo)
  {
    XxGamMaPasajerosInfoVORowImpl rowActual = null;
    //Verifica nulidad
    if (rowBase == null){
        return null;
    }else{
      try {
          rowActual = (XxGamMaPasajerosInfoVORowImpl)iterNuevo.createRow();
          //Inicializa los valores del registro
          //Los atributos Id 
          //Los attributos ticket_p_id 
          //no son llenados debido a la teoria de los Objetos View Link y Los Objetos Associate Object 
          rowActual.setName(rowBase.getName());
          rowActual.setFhoneNumber(rowBase.getFhoneNumber());
          rowActual.setNewRowState(Row.STATUS_NEW);
          
      } catch (Exception exception) {
          exception.getMessage();
          System.out.println("Excepcion desde PasajerosInfoVoImpl al "+ exception.getMessage()); 
      }
      return rowActual;
      
    }
    
  }


  /***
   * Metodo para validar si se trata de un franquicia Old o new 
   **/
  public String searchOldNewFranchise(Number idTicket)
  {
     String retval = ""; 
       try {
          clearViewCriterias();

          ViewCriteria vcPayment = null;
          ViewCriteriaRow rowVCPayment = null;

          vcPayment = createViewCriteria();
          rowVCPayment = vcPayment.createViewCriteriaRow();

          if (idTicket != null) {
            rowVCPayment.setAttribute("TicketPId", idTicket);
          }
         vcPayment.addElement(rowVCPayment);
         applyViewCriteria(vcPayment);
         executeQuery();
          if (getEstimatedRowCount() > 0) {
                  retval = "NEW";
                }else{
                  retval = "OLD"; 
                }
                
         clearViewCriterias();
        } catch (Exception exception) {
          clearViewCriterias();
        }
    return retval;     
  }
  
  /**
   * Metodo para validar cancelacion de tickets en Oficina de Boletos 
   */
   
  public boolean validateTicketsCancel()
  {
    boolean isValidToCancel = true;  
    String  strAttribute = null; 
   
    RowSetIterator pasajerosInfoIter = createRowSetIterator(null);
    pasajerosInfoIter.setRangeStart(0);
    try{
      if (pasajerosInfoIter != null){
        while (pasajerosInfoIter.hasNext()) {
          XxGamMaPasajerosInfoVORowImpl currentRow = (XxGamMaPasajerosInfoVORowImpl)pasajerosInfoIter.next();
            if (null!=currentRow){
              strAttribute = null; 
             strAttribute = currentRow.getTicketNumber();
              System.out.println(currentRow.getTicketNumber()); 
              
             if(null!=strAttribute&&!"".equals(strAttribute)){
               
               if (!"0".equals(strAttribute)){
                 isValidToCancel = false; 
                break; 
               }
               
             } 
           }
        }
      }
    }catch(Exception exception){
       System.out.println("EXCEPCION Al"+exception.getMessage()); 
      throw new OAException("Excepcion en la validacion de cancelacion de boletos "+exception.getMessage(),OAException.ERROR);
    }
      
    return isValidToCancel; 
  }

  /**
   * Metodo para recuperar el estatus de los boletos en Oficina
   * @return
   */
  public String findEstatusFoliosTickets()
  {
     String retval = null; 
     String strTicketNumber = null; 
     int countBoletosCancelados = 0; 
     int countBoletosAsociados = 0; 
     RowSetIterator PasajerosInfoIter = createRowSetIterator(null);
     PasajerosInfoIter.setRangeStart(0);
     XxGamMaPasajerosInfoVORowImpl PasajerosInfoVORowImpl  = null; 
     
     if(null!=PasajerosInfoIter){
     
     } 
        
     while(PasajerosInfoIter.hasNext()){
       strTicketNumber = null; 
       PasajerosInfoVORowImpl = (XxGamMaPasajerosInfoVORowImpl)PasajerosInfoIter.next();
        if(null!=PasajerosInfoVORowImpl){
          if(null!=PasajerosInfoVORowImpl.getTicketNumber()){
            strTicketNumber = PasajerosInfoVORowImpl.getTicketNumber(); 
            if (null!=strTicketNumber&&!"".equals(strTicketNumber)&&"0".equals(strTicketNumber)){
              countBoletosCancelados = countBoletosCancelados +1; 
            }else{
              countBoletosAsociados = countBoletosAsociados +1; 
            }
          }else{
            retval = "AlMenosUnBoletoSinAsociar"; 
            break; 
          }
        }
     }
     
     if(countBoletosCancelados>0){
       retval = "AlMenosUnBoletoCancelado"; 
     }
     
    
     if(countBoletosAsociados>0){
       if(null==retval){ 
          retval="";
       }  
       retval = retval+"AlMenosUnBoletoAsociado"; 
     }
      
    System.out.println("BoletosCancelados: "+countBoletosCancelados+"\nBoletosAsociados: "+countBoletosAsociados);
    System.out.println("Estatus de los Boletos Capa VOImpl: "+retval);
      return retval; 
  }

  /**
   * Metodo para validar que los boletos a emitir no contengan 0 
   * @return
   */
  boolean validateTicketsSendConfirmation()
  {
    
    boolean isValidToSendConfirmation = true;  
    String  strAttribute = null; 
    
    RowSetIterator pasajerosInfoIter = createRowSetIterator(null);
    pasajerosInfoIter.setRangeStart(0);
    try{
      if (pasajerosInfoIter != null){
        while (pasajerosInfoIter.hasNext()) {
          XxGamMaPasajerosInfoVORowImpl currentRow = (XxGamMaPasajerosInfoVORowImpl)pasajerosInfoIter.next();
            if (null!=currentRow){
              strAttribute = null; 
              strAttribute = currentRow.getTicketNumber();
              System.out.println(currentRow.getTicketNumber()); 
              
             if(null!=strAttribute&&!"".equals(strAttribute)){
               
               if ("0".equals(strAttribute)){
                 isValidToSendConfirmation = false; 
                break; 
               }
               
             } 
           }
        }
      }
    }catch(Exception exception){
       System.out.println("EXCEPCION Al"+exception.getMessage()); 
      throw new OAException("Excepcion en la validacion de cancelacion de boletos "+exception.getMessage(),OAException.ERROR);
    }
      
    return isValidToSendConfirmation; 
    
  }

  /**
   * Metodo para liempieza de boletos en caso de presionar no a una confirmacion o cancelacion de boletos en Oficina
   */
  void cleanTickestValues()
  {
  
    String  strAttribute = null; 
    RowSetIterator pasajerosInfoIter = createRowSetIterator(null);
    pasajerosInfoIter.setRangeStart(0);
    try{
      if (pasajerosInfoIter != null){
        while (pasajerosInfoIter.hasNext()) {
          XxGamMaPasajerosInfoVORowImpl currentRow = (XxGamMaPasajerosInfoVORowImpl)pasajerosInfoIter.next();
            if (null!=currentRow){
              strAttribute = null; 
              strAttribute = currentRow.getTicketNumber();
              System.out.println("BugCleanTickets: "+currentRow.getTicketNumber());     
             if(null!=strAttribute&&!"".equals(strAttribute)){
               currentRow.setTicketNumber(null);   
             } 
           }
        }
      }
    }catch(Exception exception){
       System.out.println("EXCEPCION Al"+exception.getMessage()); 
      throw new OAException("Excepcion en la validacion de cancelacion de boletos "+exception.getMessage(),OAException.ERROR);
    }
    
  }
  
}
